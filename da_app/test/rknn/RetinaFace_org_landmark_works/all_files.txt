# File: CMakeLists.txt
cmake_minimum_required(VERSION 3.10)

project(rknn_retinaface_demo)

if (ENABLE_ASAN)
	message(STATUS "BUILD WITH ADDRESS SANITIZER")
	set (CMAKE_C_FLAGS_DEBUG "${CMAKE_C_FLAGS_DEBUG} -fno-omit-frame-pointer -fsanitize=address")
	set (CMAKE_CXX_FLAGS_DEBUG "${CMAKE_CXX_FLAGS_DEBUG} -fno-omit-frame-pointer -fsanitize=address")
	set (CMAKE_LINKER_FLAGS_DEBUG "${CMAKE_LINKER_FLAGS_DEBUG} -fno-omit-frame-pointer -fsanitize=address")
endif ()

add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/../../../3rdparty/ 3rdparty.out)
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/../../../utils/ utils.out)

set(CMAKE_INSTALL_RPATH "$ORIGIN/../lib")

if (TARGET_SOC STREQUAL "rk1808" OR TARGET_SOC STREQUAL "rv1109" OR TARGET_SOC STREQUAL "rv1126")
    set(retinaface_file rknpu1/retinaface.cc)
else()
    set(retinaface_file rknpu2/retinaface.cc)
endif()

file(GLOB SRCS ${CMAKE_CURRENT_SOURCE_DIR}/*.cc)


add_executable(${PROJECT_NAME}
    main.cc
    ${retinaface_file}
)

target_link_libraries(${PROJECT_NAME}
    fileutils
    imageutils
    imagedrawing
    ${LIBRKNNRT}
    dl
)

if (CMAKE_SYSTEM_NAME STREQUAL "Android")
    target_link_libraries(${PROJECT_NAME} log )
endif()

if (CMAKE_SYSTEM_NAME STREQUAL "Linux")
    set(THREADS_PREFER_PTHREAD_FLAG ON)
    find_package(Threads REQUIRED)
    target_link_libraries(${PROJECT_NAME} Threads::Threads)
endif()



target_include_directories(${PROJECT_NAME} PRIVATE
    ${CMAKE_CURRENT_SOURCE_DIR}
    ${LIBRKNNRT_INCLUDES}
)

install(TARGETS ${PROJECT_NAME} DESTINATION .)
install(FILES ${CMAKE_CURRENT_SOURCE_DIR}/../model/test.jpg DESTINATION model)
set(filed_path ${CMAKE_CURRENT_SOURCE_DIR}/../model/faceD.rknn)
set(filel_path ${CMAKE_CURRENT_SOURCE_DIR}/../model/faceL.rknn)

if (EXISTS ${filed_path})
    install(FILES ${filed_path} DESTINATION model)
endif()
if (EXISTS ${filel_path})
    install(FILES ${filel_path} DESTINATION model)
endif()

# File: main.cc
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "retinaface.h"
#include "image_utils.h"
#include "image_drawing.h"
#include "file_utils.h"

int main(int argc, char **argv) {
    if (argc != 4) {
        printf("%s <face_model_path> <landmark_model_path> <image_path>\n", argv[0]);
        return -1;
    }

    const char *face_model_path = argv[1];
    const char *landmark_model_path = argv[2];
    const char *image_path = argv[3];
    int ret;

    // Initialize application context
    rknn_app_context_t rknn_app_ctx;
    memset(&rknn_app_ctx, 0, sizeof(rknn_app_context_t));

    // Initialize face detection model
    ret = init_face_detection_model(face_model_path, &rknn_app_ctx.face_detect_ctx);
    if (ret != 0) {
        printf("init_face_detection_model fail! ret=%d model_path=%s\n", ret, face_model_path);
        return -1;
    }

    // Initialize landmark model
    ret = init_landmark_model(landmark_model_path, &rknn_app_ctx.landmark_ctx);
    if (ret != 0) {
        printf("init_landmark_model fail! ret=%d model_path=%s\n", ret, landmark_model_path);
        release_face_detection_model(&rknn_app_ctx.face_detect_ctx);
        return -1;
    }

    // Read the input image
    image_buffer_t src_image;
    memset(&src_image, 0, sizeof(image_buffer_t));
    ret = read_image(image_path, &src_image);
    if (ret != 0) {
        printf("read image fail! ret=%d image_path=%s\n", ret, image_path);
        release_face_detection_model(&rknn_app_ctx.face_detect_ctx);
        release_landmark_model(&rknn_app_ctx.landmark_ctx);
        return -1;
    }

    // Run inference
    retinaface_result result;
    result.object.resize(128);  // Pre-allocate memory
    ret = inference_retinaface_model(&rknn_app_ctx, &src_image, &result);
    if (ret != 0) {
        printf("inference_retinaface_model fail! ret=%d\n", ret);
        goto out;
    }

    // Draw results
    for (int i = 0; i < result.count; ++i) {
        int rx = result.object[i].box.left;
        int ry = result.object[i].box.top;
        int rw = result.object[i].box.right - result.object[i].box.left;
        int rh = result.object[i].box.bottom - result.object[i].box.top;
        draw_rectangle(&src_image, rx, ry, rw, rh, COLOR_GREEN, 3);

        char score_text[20];
        snprintf(score_text, 20, "%0.2f", result.object[i].score);
        printf("face @(%d %d %d %d) score=%f\n", result.object[i].box.left, result.object[i].box.top,
               result.object[i].box.right, result.object[i].box.bottom, result.object[i].score);
        draw_text(&src_image, score_text, rx, ry, COLOR_RED, 20);

        for(int j = 0; j < 5; j++) {
            draw_circle(&src_image, result.object[i].ponit[j].x, result.object[i].ponit[j].y, 2, COLOR_ORANGE, 4);
        }
    }
    write_image("result.jpg", &src_image);

out:
    // Release resources
    release_face_detection_model(&rknn_app_ctx.face_detect_ctx);
    release_landmark_model(&rknn_app_ctx.landmark_ctx);

    if (src_image.virt_addr != NULL) {
        free(src_image.virt_addr);
    }

    return 0;
}

# File: retinaface.h
#ifndef RKNN_DEMO_RETINAFACE_H
#define RKNN_DEMO_RETINAFACE_H

#include "rknn_api.h"
#include "common.h"
#include "image_utils.h" // Make sure image_utils.h is included
#include <vector>

typedef struct {
    rknn_context rknn_ctx;
    rknn_input_output_num io_num;
    rknn_tensor_attr *input_attrs;
    rknn_tensor_attr *output_attrs;
    int model_channel;
    int model_width;
    int model_height;
} rknn_model_context_t;

typedef struct box_rect_t {
    int left;    ///< Most left coordinate
    int top;     ///< Most top coordinate
    int right;   ///< Most right coordinate
    int bottom;  ///< Most bottom coordinate
} box_rect_t;

typedef struct ponit_t {
    int x;
    int y;
} ponit_t;

typedef struct retinaface_object_t {
    int cls;
    box_rect_t box;
    float score;
    ponit_t ponit[5];
} retinaface_object_t;

typedef struct {
    int count;
    std::vector<retinaface_object_t> object; // Use a vector for dynamic size
} retinaface_result;

typedef struct {
    rknn_model_context_t face_detect_ctx;
    rknn_model_context_t landmark_ctx;
} rknn_app_context_t;

int init_face_detection_model(const char *model_path, rknn_model_context_t *model_ctx);
int init_landmark_model(const char *model_path, rknn_model_context_t *model_ctx);

int release_face_detection_model(rknn_model_context_t *model_ctx);
int release_landmark_model(rknn_model_context_t *model_ctx);

int inference_retinaface_model(rknn_app_context_t *app_ctx, image_buffer_t *img, retinaface_result *out_result);

#endif // RKNN_DEMO_RETINAFACE_H

# File: retinaface.cc
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <algorithm>  // Added for std::sort
#include <numeric>   // Added for std::iota

#include "retinaface.h"
#include "common.h"
#include "file_utils.h"
#include "image_utils.h"

// Move clamp function to the top
static int clamp(int x, int min, int max) {
    if (x > max) return max;
    if (x < min) return min;
    return x;
}

static int image_crop_resize(image_buffer_t *src, image_buffer_t *dst, int x, int y, int width, int height) {
    // Check for valid input
    if (src == nullptr || dst == nullptr || src->virt_addr == nullptr || dst->virt_addr == nullptr) {
        printf("Error: Invalid input to image_crop_resize\n");
        return -1;
    }

    // Clamp the crop region to be within the source image
    int crop_x = clamp(x, 0, src->width - 1);
    int crop_y = clamp(y, 0, src->height - 1);
    int crop_width = clamp(width, 0, src->width - crop_x);
    int crop_height = clamp(height, 0, src->height - crop_y);

    // Calculate scaling factors
    float scale_x = (float)dst->width / crop_width;
    float scale_y = (float)dst->height / crop_height;

    for (int j = 0; j < dst->height; ++j) {
        for (int i = 0; i < dst->width; ++i) {
            // Calculate corresponding coordinates in the source image
            float src_x = i / scale_x + crop_x;
            float src_y = j / scale_y + crop_y;

            // Bilinear interpolation
            int x1 = (int)src_x;
            int y1 = (int)src_y;
            int x2 = x1 + 1;
            int y2 = y1 + 1;

            // Ensure the coordinates are within the source image bounds
            x1 = clamp(x1, 0, src->width - 1);
            y1 = clamp(y1, 0, src->height - 1);
            x2 = clamp(x2, 0, src->width - 1);
            y2 = clamp(y2, 0, src->height - 1);

            float x_ratio = src_x - x1;
            float y_ratio = src_y - y1;

            unsigned char *dst_pixel = dst->virt_addr + (j * dst->width + i) * 3;

            if (src->format == IMAGE_FORMAT_RGB888) {
                unsigned char *src_pixel11 = src->virt_addr + (y1 * src->width + x1) * 3;
                unsigned char *src_pixel12 = src->virt_addr + (y1 * src->width + x2) * 3;
                unsigned char *src_pixel21 = src->virt_addr + (y2 * src->width + x1) * 3;
                unsigned char *src_pixel22 = src->virt_addr + (y2 * src->width + x2) * 3;

                dst_pixel[0] = (unsigned char)(
                    (1 - x_ratio) * (1 - y_ratio) * src_pixel11[0] +
                    x_ratio * (1 - y_ratio) * src_pixel12[0] +
                    (1 - x_ratio) * y_ratio * src_pixel21[0] +
                    x_ratio * y_ratio * src_pixel22[0]);
                dst_pixel[1] = (unsigned char)(
                    (1 - x_ratio) * (1 - y_ratio) * src_pixel11[1] +
                    x_ratio * (1 - y_ratio) * src_pixel12[1] +
                    (1 - x_ratio) * y_ratio * src_pixel21[1] +
                    x_ratio * y_ratio * src_pixel22[1]);
                dst_pixel[2] = (unsigned char)(
                    (1 - x_ratio) * (1 - y_ratio) * src_pixel11[2] +
                    x_ratio * (1 - y_ratio) * src_pixel12[2] +
                    (1 - x_ratio) * y_ratio * src_pixel21[2] +
                    x_ratio * y_ratio * src_pixel22[2]);
            } else {
                printf("Error: Unsupported source image format for cropping and resizing\n");
                return -1;
            }
        }
    }

    return 0;
}

#define NMS_THRESHOLD 0.4
#define CONF_THRESHOLD 0.5
#define VIS_THRESHOLD 0.4

//static int clamp(int x, int min, int max) {  // Moved to the top
//    if (x > max) return max;
//    if (x < min) return min;
//    return x;
//}

static void dump_tensor_attr(rknn_tensor_attr *attr) {
    printf("  index=%d, name=%s, n_dims=%d, dims=[%d, %d, %d, %d], n_elems=%d, size=%d, fmt=%s, type=%s, qnt_type=%s, "
           "zp=%d, scale=%f\n",
           attr->index, attr->name, attr->n_dims, attr->dims[0], attr->dims[1], attr->dims[2], attr->dims[3],
           attr->n_elems, attr->size, get_format_string(attr->fmt), get_type_string(attr->type),
           get_qnt_type_string(attr->qnt_type), attr->zp, attr->scale);
}

static float CalculateOverlap(float xmin0, float ymin0, float xmax0, float ymax0, float xmin1, float ymin1, float xmax1, float ymax1) {
    float w = fmax(0.f, fmin(xmax0, xmax1) - fmax(xmin0, xmin1) + 1);
    float h = fmax(0.f, fmin(ymax0, ymax1) - fmax(ymin0, ymin1) + 1);
    float i = w * h;
    float u = (xmax0 - xmin0 + 1) * (ymax0 - ymin0 + 1) + (xmax1 - xmin1 + 1) * (ymax1 - ymin1 + 1) - i;
    return u <= 0.f ? 0.f : (i / u);
}

static int nms(std::vector<retinaface_object_t>& objects, float threshold, float width, float height) {
    std::vector<size_t> sorted_indices(objects.size());
    std::iota(sorted_indices.begin(), sorted_indices.end(), 0);

    // Sort by confidence (highest to lowest)
    std::sort(sorted_indices.begin(), sorted_indices.end(),
              [&](size_t i1, size_t i2) { return objects[i1].score > objects[i2].score; });

    std::vector<bool> keep(objects.size(), true);
    for (size_t i = 0; i < objects.size(); ++i) {
        if (!keep[sorted_indices[i]]) continue;

        for (size_t j = i + 1; j < objects.size(); ++j) {
            if (!keep[sorted_indices[j]]) continue;

            float xmin0 = objects[sorted_indices[i]].box.left;
            float ymin0 = objects[sorted_indices[i]].box.top;
            float xmax0 = objects[sorted_indices[i]].box.right;
            float ymax0 = objects[sorted_indices[i]].box.bottom;

            float xmin1 = objects[sorted_indices[j]].box.left;
            float ymin1 = objects[sorted_indices[j]].box.top;
            float xmax1 = objects[sorted_indices[j]].box.right;
            float ymax1 = objects[sorted_indices[j]].box.bottom;

            float iou = CalculateOverlap(xmin0, ymin0, xmax0, ymax0, xmin1, ymin1, xmax1, ymax1);

            if (iou > threshold) {
                keep[sorted_indices[j]] = false;
            }
        }
    }

    // Filter out the boxes that are not kept
    std::vector<retinaface_object_t> filtered_objects;
    for (size_t i = 0; i < objects.size(); ++i) {
        if (keep[i]) {
            filtered_objects.push_back(objects[i]);
        }
    }

    objects = filtered_objects;
    return 0;
}

// Initialize the face detection model
int init_face_detection_model(const char *model_path, rknn_model_context_t *model_ctx) {
    int ret;
    int model_len = 0;
    char *model;
    rknn_context ctx = 0;

    // Load RKNN Model
    model_len = read_data_from_file(model_path, &model);
    if (model == NULL) {
        printf("load_model fail!\n");
        return -1;
    }

    ret = rknn_init(&ctx, model, model_len, 0, NULL);
    free(model);
    if (ret < 0) {
        printf("rknn_init fail! ret=%d\n", ret);
        return -1;
    }

    // Get Model Input Output Number
    rknn_input_output_num io_num;
    ret = rknn_query(ctx, RKNN_QUERY_IN_OUT_NUM, &io_num, sizeof(io_num));
    if (ret != RKNN_SUCC) {
        printf("rknn_query fail! ret=%d\n", ret);
        return -1;
    }
    printf("model input num: %d, output num: %d\n", io_num.n_input, io_num.n_output);

    // Get Model Input Info
    printf("input tensors:\n");
    rknn_tensor_attr input_attrs[io_num.n_input];
    memset(input_attrs, 0, sizeof(input_attrs));
    for (int i = 0; i < io_num.n_input; i++) {
        input_attrs[i].index = i;
        ret = rknn_query(ctx, RKNN_QUERY_INPUT_ATTR, &(input_attrs[i]), sizeof(rknn_tensor_attr));
        if (ret != RKNN_SUCC) {
            printf("rknn_query fail! ret=%d\n", ret);
            return -1;
        }
        dump_tensor_attr(&(input_attrs[i]));
    }

    // Get Model Output Info
    printf("output tensors:\n");
    rknn_tensor_attr output_attrs[io_num.n_output];
    memset(output_attrs, 0, sizeof(output_attrs));
    for (int i = 0; i < io_num.n_output; i++) {
        output_attrs[i].index = i;
        ret = rknn_query(ctx, RKNN_QUERY_OUTPUT_ATTR, &(output_attrs[i]), sizeof(rknn_tensor_attr));
        if (ret != RKNN_SUCC) {
            printf("rknn_query fail! ret=%d\n", ret);
            return -1;
        }
        dump_tensor_attr(&(output_attrs[i]));
    }

    // Set to context
    model_ctx->rknn_ctx = ctx;
    model_ctx->io_num = io_num;
    model_ctx->input_attrs = (rknn_tensor_attr *)malloc(io_num.n_input * sizeof(rknn_tensor_attr));
    memcpy(model_ctx->input_attrs, input_attrs, io_num.n_input * sizeof(rknn_tensor_attr));
    model_ctx->output_attrs = (rknn_tensor_attr *)malloc(io_num.n_output * sizeof(rknn_tensor_attr));
    memcpy(model_ctx->output_attrs, output_attrs, io_num.n_output * sizeof(rknn_tensor_attr));

    if (input_attrs[0].fmt == RKNN_TENSOR_NCHW) {
        printf("model is NCHW input fmt\n");
        model_ctx->model_channel = input_attrs[0].dims[1];
        model_ctx->model_height  = input_attrs[0].dims[2];
        model_ctx->model_width   = input_attrs[0].dims[3];
    } else {
        printf("model is NHWC input fmt\n");
        model_ctx->model_height  = input_attrs[0].dims[1];
        model_ctx->model_width   = input_attrs[0].dims[2];
        model_ctx->model_channel = input_attrs[0].dims[3];
    }
    printf("model input height=%d, width=%d, channel=%d\n",
           model_ctx->model_height, model_ctx->model_width, model_ctx->model_channel);

    return 0;
}

// Initialize the landmark model
int init_landmark_model(const char *model_path, rknn_model_context_t *model_ctx) {
     int ret;
    int model_len = 0;
    char *model;
    rknn_context ctx = 0;

    // Load RKNN Model
    model_len = read_data_from_file(model_path, &model);
    if (model == NULL) {
        printf("load_model fail!\n");
        return -1;
    }

    ret = rknn_init(&ctx, model, model_len, 0, NULL);
    free(model);
    if (ret < 0) {
        printf("rknn_init fail! ret=%d\n", ret);
        return -1;
    }

    // Get Model Input Output Number
    rknn_input_output_num io_num;
    ret = rknn_query(ctx, RKNN_QUERY_IN_OUT_NUM, &io_num, sizeof(io_num));
    if (ret != RKNN_SUCC) {
        printf("rknn_query fail! ret=%d\n", ret);
        return -1;
    }
    printf("model input num: %d, output num: %d\n", io_num.n_input, io_num.n_output);

    // Get Model Input Info
    printf("input tensors:\n");
    rknn_tensor_attr input_attrs[io_num.n_input];
    memset(input_attrs, 0, sizeof(input_attrs));
    for (int i = 0; i < io_num.n_input; i++) {
        input_attrs[i].index = i;
        ret = rknn_query(ctx, RKNN_QUERY_INPUT_ATTR, &(input_attrs[i]), sizeof(rknn_tensor_attr));
        if (ret != RKNN_SUCC) {
            printf("rknn_query fail! ret=%d\n", ret);
            return -1;
        }
        dump_tensor_attr(&(input_attrs[i]));
    }

    // Get Model Output Info
    printf("output tensors:\n");
    rknn_tensor_attr output_attrs[io_num.n_output];
    memset(output_attrs, 0, sizeof(output_attrs));
    for (int i = 0; i < io_num.n_output; i++) {
        output_attrs[i].index = i;
        ret = rknn_query(ctx, RKNN_QUERY_OUTPUT_ATTR, &(output_attrs[i]), sizeof(rknn_tensor_attr));
        if (ret != RKNN_SUCC) {
            printf("rknn_query fail! ret=%d\n", ret);
            return -1;
        }
        dump_tensor_attr(&(output_attrs[i]));
    }

    // Set to context
    model_ctx->rknn_ctx = ctx;
    model_ctx->io_num = io_num;
    model_ctx->input_attrs = (rknn_tensor_attr *)malloc(io_num.n_input * sizeof(rknn_tensor_attr));
    memcpy(model_ctx->input_attrs, input_attrs, io_num.n_input * sizeof(rknn_tensor_attr));
    model_ctx->output_attrs = (rknn_tensor_attr *)malloc(io_num.n_output * sizeof(rknn_tensor_attr));
    memcpy(model_ctx->output_attrs, output_attrs, io_num.n_output * sizeof(rknn_tensor_attr));

    if (input_attrs[0].fmt == RKNN_TENSOR_NCHW) {
        printf("model is NCHW input fmt\n");
        model_ctx->model_channel = input_attrs[0].dims[1];
        model_ctx->model_height  = input_attrs[0].dims[2];
        model_ctx->model_width   = input_attrs[0].dims[3];
    } else {
        printf("model is NHWC input fmt\n");
        model_ctx->model_height  = input_attrs[0].dims[1];
        model_ctx->model_width   = input_attrs[0].dims[2];
        model_ctx->model_channel = input_attrs[0].dims[3];
    }
    printf("model input height=%d, width=%d, channel=%d\n",
           model_ctx->model_height, model_ctx->model_width, model_ctx->model_channel);

    return 0;
}

int release_face_detection_model(rknn_model_context_t *model_ctx) {
    if (model_ctx->input_attrs != NULL) {
        free(model_ctx->input_attrs);
        model_ctx->input_attrs = NULL;
    }
    if (model_ctx->output_attrs != NULL) {
        free(model_ctx->output_attrs);
        model_ctx->output_attrs = NULL;
    }
    if (model_ctx->rknn_ctx != 0) {
        rknn_destroy(model_ctx->rknn_ctx);
        model_ctx->rknn_ctx = 0;
    }
    return 0;
}

int release_landmark_model(rknn_model_context_t *model_ctx) {
    if (model_ctx->input_attrs != NULL) {
        free(model_ctx->input_attrs);
        model_ctx->input_attrs = NULL;
    }
    if (model_ctx->output_attrs != NULL) {
        free(model_ctx->output_attrs);
        model_ctx->output_attrs = NULL;
    }
    if (model_ctx->rknn_ctx != 0) {
        rknn_destroy(model_ctx->rknn_ctx);
        model_ctx->rknn_ctx = 0;
    }
    return 0;
}

static int get_channel_count(image_buffer_t *img) {
    switch (img->format) {
        case IMAGE_FORMAT_RGB888:
            return 3;
        case IMAGE_FORMAT_GRAY8:
            return 1;
        default:
            return 3; // Default to 3 if unknown format
    }
}

// Function to run the face detection model
std::vector<retinaface_object_t> run_face_detection(rknn_model_context_t *face_ctx, image_buffer_t *src_img, float orig_width, float orig_height) {
    std::vector<retinaface_object_t> detected_faces;
    int ret;

    // Prepare input for face detection model
    rknn_input inputs[1];
    memset(inputs, 0, sizeof(inputs));
    inputs[0].index = 0;
    inputs[0].type = RKNN_TENSOR_UINT8;
    inputs[0].fmt = RKNN_TENSOR_NHWC;
    inputs[0].size = src_img->width * src_img->height * get_channel_count(src_img);
    inputs[0].buf = src_img->virt_addr;

    ret = rknn_inputs_set(face_ctx->rknn_ctx, 1, inputs);
    if (ret < 0) {
        printf("rknn_input_set fail! ret=%d\n", ret);
        return detected_faces;
    }

    // Run face detection inference
    ret = rknn_run(face_ctx->rknn_ctx, nullptr);
    if (ret < 0) {
        printf("rknn_run fail! ret=%d\n", ret);
        return detected_faces;
    }

     // Get face detection output
    rknn_output outputs[2]; // Now expecting two outputs
    memset(outputs, 0, sizeof(outputs));
    outputs[0].index = 0;
    outputs[0].want_float = 1;
    outputs[1].index = 1;
    outputs[1].want_float = 1;

    ret = rknn_outputs_get(face_ctx->rknn_ctx, 2, outputs, NULL);
    if (ret < 0) {
        printf("rknn_outputs_get fail! ret=%d\n", ret);
        return detected_faces;
    }
    // Process face detections
    float *regressors = (float *)outputs[0].buf;  // bounding box regressions
    float *classificators = (float *)outputs[1].buf;  // face/non-face scores
    int num_boxes = face_ctx->output_attrs[0].dims[1];  // Number of bounding boxes
    float scale_x = orig_width / face_ctx->model_width; // Scaling factors for original image size
    float scale_y = orig_height / face_ctx->model_height;
    // Assuming the output format is [xmin, ymin, xmax, ymax, confidence] * num_boxes
    for (int i = 0; i < num_boxes; i++) {

        float confidence = classificators[i];  // confidence score for each box
       if (confidence > CONF_THRESHOLD) { // Apply confidence threshold
            retinaface_object_t face;

            // Decode the bounding box.  **THIS IS THE CRITICAL PART**
            face.box.left = (int)(regressors[i * 16 + 0] * scale_x);
            face.box.top = (int)(regressors[i * 16 + 1] * scale_y);
            face.box.right = (int)(regressors[i * 16 + 2] * scale_x);
            face.box.bottom = (int)(regressors[i * 16 + 3] * scale_y);
            face.score = confidence;

             // Clamp the bounding box coordinates
            face.box.left = clamp(face.box.left, 0, (int)orig_width - 1);
            face.box.top = clamp(face.box.top, 0, (int)orig_height - 1);
            face.box.right = clamp(face.box.right, face.box.left + 1, (int)orig_width); // Ensure right > left
            face.box.bottom = clamp(face.box.bottom, face.box.top + 1, (int)orig_height);   // Ensure bottom > top
            detected_faces.push_back(face);
        }
    }

     rknn_outputs_release(face_ctx->rknn_ctx, 2, outputs); // Release both output buffers

    return detected_faces;
}
// Function to run the landmark detection model on a cropped face
std::vector<ponit_t> run_landmark_detection(rknn_model_context_t *landmark_ctx, image_buffer_t *face_img) {
    std::vector<ponit_t> landmarks;
    int ret;

    // Prepare input for landmark model
    rknn_input inputs[1];
    memset(inputs, 0, sizeof(inputs));
    inputs[0].index = 0;
    inputs[0].type = RKNN_TENSOR_UINT8;  // Assuming UINT8. Adjust if needed.
    inputs[0].fmt = RKNN_TENSOR_NHWC; // Assuming NHWC.  Adjust if needed.
    inputs[0].size = face_img->width * face_img->height * get_channel_count(face_img);
    inputs[0].buf = face_img->virt_addr;

    ret = rknn_inputs_set(landmark_ctx->rknn_ctx, 1, inputs);
    if (ret < 0) {
        printf("rknn_input_set fail! ret=%d\n", ret);
        return landmarks; // Return empty vector if fails
    }

    // Run landmark inference
    ret = rknn_run(landmark_ctx->rknn_ctx, nullptr);
    if (ret < 0) {
        printf("rknn_run fail! ret=%d\n", ret);
        return landmarks; // Return empty vector if fails
    }

    // Get landmark output
    rknn_output outputs[1];  // Assuming 1 output for landmarks
    memset(outputs, 0, sizeof(outputs));
    outputs[0].index = 0;
    outputs[0].want_float = 1; // Assuming you want the output in float.  Adjust if needed.
    ret = rknn_outputs_get(landmark_ctx->rknn_ctx, 1, outputs, NULL);
    if (ret < 0) {
        printf("rknn_outputs_get fail! ret=%d\n", ret);
        return landmarks; // Return empty vector if fails
    }

   float *output_data = (float *)outputs[0].buf;

    // Get the number of landmarks from the output tensor's dimensions
    int num_landmarks = landmark_ctx->output_attrs[0].dims[3] / 2;
     float scale_x = face_img->width / 192;
    float scale_y = face_img->height / 192;

    // Process landmarks
    for (int i = 0; i < num_landmarks; ++i) {
        ponit_t landmark;
         // Scaling landmark points to face image dimensions (assuming that output values between 0 and 1, need scaling based on output tensor)
        landmark.x = (int)(output_data[i * 2 + 0] * scale_x);  // Assuming x is at index 0. Adjust if needed.
        landmark.y = (int)(output_data[i * 2 + 1] * scale_y); // Assuming y is at index 1. Adjust if needed.
        landmarks.push_back(landmark);
    }
    rknn_outputs_release(landmark_ctx->rknn_ctx, 1, outputs); // Release the output buffer
    return landmarks;
}

int inference_retinaface_model(rknn_app_context_t *app_ctx, image_buffer_t *src_img, retinaface_result *out_result) {
    int ret;

     // Create resized image buffer for face detection model input
    image_buffer_t face_detect_input;
    memset(&face_detect_input, 0, sizeof(image_buffer_t));
    face_detect_input.width = app_ctx->face_detect_ctx.model_width;
    face_detect_input.height = app_ctx->face_detect_ctx.model_height;
    face_detect_input.format = src_img->format;  // keep format as the original image
    face_detect_input.size = get_image_size(&face_detect_input);
    face_detect_input.virt_addr = (unsigned char *)malloc(face_detect_input.size);
    if (face_detect_input.virt_addr == NULL) {
        printf("malloc buffer size:%d fail!\n", face_detect_input.size);
        return -1;
    }

    ret = image_crop_resize(src_img, &face_detect_input, 0, 0, src_img->width, src_img->height);

     if (ret < 0) {
        printf("image_crop_resize failed!\n");
        free(face_detect_input.virt_addr);
        return -1;
    }

    // 1. Run Face Detection
    std::vector<retinaface_object_t> detected_faces = run_face_detection(&app_ctx->face_detect_ctx, &face_detect_input,src_img->width, src_img->height);
    nms(detected_faces, NMS_THRESHOLD, src_img->width, src_img->height);
    free(face_detect_input.virt_addr);

    out_result->object = detected_faces;
    out_result->count = detected_faces.size();
    // 2. For each detected face, run Landmark Extraction
    for (size_t i = 0; i < detected_faces.size(); ++i) {
        // Crop the face from the original image
        image_buffer_t face_img;
        memset(&face_img, 0, sizeof(image_buffer_t));
        face_img.width = app_ctx->landmark_ctx.model_width;
        face_img.height = app_ctx->landmark_ctx.model_height;
        face_img.format = IMAGE_FORMAT_RGB888;
        face_img.size = get_image_size(&face_img);
        face_img.virt_addr = (unsigned char *)malloc(face_img.size);

        if (face_img.virt_addr == NULL) {
            printf("malloc buffer size:%d fail!\n", face_img.size);
            continue;
        }

        ret = image_crop_resize(src_img, &face_img, detected_faces[i].box.left, detected_faces[i].box.top,
                               detected_faces[i].box.right - detected_faces[i].box.left, detected_faces[i].box.bottom - detected_faces[i].box.top);

        if (ret < 0) {
            printf("crop_and_resize failed!\n");
            free(face_img.virt_addr);
            continue;
        }

        // Run Landmark Detection
        std::vector<ponit_t> landmarks = run_landmark_detection(&app_ctx->landmark_ctx, &face_img);

        // Assign landmarks to the detected face
        for (int j = 0; j < 5 && j < landmarks.size(); ++j) {
            out_result->object[i].ponit[j] = landmarks[j];
        }

        free(face_img.virt_addr);
    }

    return 0;
}

# File: retinaface.cc
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

#include "retinaface.h"
#include "common.h"
#include "file_utils.h"
#include "image_utils.h"
#include "rknn_box_priors.h"

#define NMS_THRESHOLD 0.4
#define CONF_THRESHOLD 0.5
#define VIS_THRESHOLD 0.4

static int clamp(int x, int min, int max) {
    if (x > max) return max;
    if (x < min) return min;
    return x;
}

static void dump_tensor_attr(rknn_tensor_attr *attr) {
    printf("  index=%d, name=%s, n_dims=%d, dims=[%d, %d, %d, %d], n_elems=%d, size=%d, fmt=%s, type=%s, qnt_type=%s, "
           "zp=%d, scale=%f\n",
           attr->index, attr->name, attr->n_dims, attr->dims[3], attr->dims[2], attr->dims[1], attr->dims[0],
           attr->n_elems, attr->size, get_format_string(attr->fmt), get_type_string(attr->type),
           get_qnt_type_string(attr->qnt_type), attr->zp, attr->scale);
}

static float CalculateOverlap(float xmin0, float ymin0, float xmax0, float ymax0, float xmin1, float ymin1, float xmax1, float ymax1) {
    float w = fmax(0.f, fmin(xmax0, xmax1) - fmax(xmin0, xmin1) + 1);
    float h = fmax(0.f, fmin(ymax0, ymax1) - fmax(ymin0, ymin1) + 1);
    float i = w * h;
    float u = (xmax0 - xmin0 + 1) * (ymax0 - ymin0 + 1) + (xmax1 - xmin1 + 1) * (ymax1 - ymin1 + 1) - i;
    return u <= 0.f ? 0.f : (i / u);
}

static int nms(int validCount, float *outputLocations, int order[], float threshold, int width, int height) {
    for (int i = 0; i < validCount; ++i) {
        if (order[i] == -1) {
            continue;
        }
        int n = order[i];
        for (int j = i + 1; j < validCount; ++j) {
            int m = order[j];
            if (m == -1) {
                continue;
            }
            float xmin0 = outputLocations[n * 4 + 0] * width;
            float ymin0 = outputLocations[n * 4 + 1] * height;
            float xmax0 = outputLocations[n * 4 + 2] * width;
            float ymax0 = outputLocations[n * 4 + 3] * height;

            float xmin1 = outputLocations[m * 4 + 0] * width;
            float ymin1 = outputLocations[m * 4 + 1] * height;
            float xmax1 = outputLocations[m * 4 + 2] * width;
            float ymax1 = outputLocations[m * 4 + 3] * height;

            float iou = CalculateOverlap(xmin0, ymin0, xmax0, ymax0, xmin1, ymin1, xmax1, ymax1);

            if (iou > threshold) {
                order[j] = -1;
            }
        }
    }
    return 0;
}

static int quick_sort_indice_inverse(float *input, int left, int right, int *indices) {
    float key;
    int key_index;
    int low = left;
    int high = right;
    if (left < right) {
        key_index = indices[left];
        key = input[left];
        while (low < high) {
            while (low < high && input[high] <= key) {
                high--;
            }
            input[low] = input[high];
            indices[low] = indices[high];
            while (low < high && input[low] >= key) {
                low++;
            }
            input[high] = input[low];
            indices[high] = indices[low];
        }
        input[low] = key;
        indices[low] = key_index;
        quick_sort_indice_inverse(input, left, low - 1, indices);
        quick_sort_indice_inverse(input, low + 1, right, indices);
    }
    return low;
}

static int filterValidResult(float *scores, float *loc, float *landms, const float boxPriors[][4], int model_in_h, int model_in_w,
                             int filter_indice[], float *props, float threshold, const int num_results) {
    int validCount = 0;
    const float VARIANCES[2] = {0.1, 0.2};
    // Scale them back to the input size.
    for (int i = 0; i < num_results; ++i) {
        float face_score = scores[i * 2 + 1];
        if (face_score > threshold) {
            filter_indice[validCount] = i;
            props[validCount] = face_score;
            //decode location to origin position
            float xcenter = loc[i * 4 + 0] * VARIANCES[0] * boxPriors[i][2] + boxPriors[i][0];
            float ycenter = loc[i * 4 + 1] * VARIANCES[0] * boxPriors[i][3] + boxPriors[i][1];
            float w = (float) expf(loc[i * 4 + 2] * VARIANCES[1] ) * boxPriors[i][2];
            float h = (float) expf(loc[i * 4 + 3] * VARIANCES[1]) * boxPriors[i][3];

            float xmin = xcenter - w * 0.5f;
            float ymin = ycenter - h * 0.5f;
            float xmax = xmin + w;
            float ymax = ymin + h;

            loc[i * 4 + 0] = xmin ;
            loc[i * 4 + 1] = ymin ;
            loc[i * 4 + 2] = xmax ;
            loc[i * 4 + 3] = ymax ;
            for (int j = 0; j < 5; ++j) {
                landms[i * 10 + 2 * j] = landms[i * 10 + 2 * j] * VARIANCES[0] * boxPriors[i][2] + boxPriors[i][0];
                landms[i * 10 + 2 * j + 1] = landms[i * 10 + 2 * j + 1] * VARIANCES[0] * boxPriors[i][3] + boxPriors[i][1];
            }
            ++validCount;
        }
    }

    return validCount;
}

static int post_process_retinaface(rknn_app_context_t *app_ctx, image_buffer_t *src_img, rknn_output outputs[], retinaface_result *result, letterbox_t *letter_box) {
    float *location = (float *)outputs[0].buf;
    float *scores = (float *)outputs[1].buf;
    float *landms = (float *)outputs[2].buf;
    const float (*prior_ptr)[4];
    int num_priors = 0;
    if (app_ctx->model_height == 320) {
        num_priors = 4200;//anchors box number
        prior_ptr = BOX_PRIORS_320;
    } else if(app_ctx->model_height == 640){
        num_priors = 16800;//anchors box number
        prior_ptr = BOX_PRIORS_640;
    }
    else
    {
        printf("model_shape error!!!\n");
        return -1;

    }

    int filter_indices[num_priors];
    float props[num_priors];

    memset(filter_indices, 0, sizeof(int)*num_priors);
    memset(props, 0, sizeof(float)*num_priors);

    int validCount = filterValidResult(scores, location, landms, prior_ptr, app_ctx->model_height, app_ctx->model_width,
                                       filter_indices, props, CONF_THRESHOLD, num_priors);

    quick_sort_indice_inverse(props, 0, validCount - 1, filter_indices);
    nms(validCount, location, filter_indices, NMS_THRESHOLD, src_img->width, src_img->height);


    int last_count = 0;
    result->count = 0;
    for (int i = 0; i < validCount; ++i) {
        if (last_count >= 128) {
            printf("Warning: detected more than 128 faces, can not handle that");
            break;
        }
        if (filter_indices[i] == -1 || props[i] < VIS_THRESHOLD) {
            continue;
        }

        int n = filter_indices[i];

        float x1 = location[n * 4 + 0] * app_ctx->model_width - letter_box->x_pad;
        float y1 = location[n * 4 + 1] * app_ctx->model_height - letter_box->y_pad;
        float x2 = location[n * 4 + 2] * app_ctx->model_width - letter_box->x_pad;
        float y2 = location[n * 4 + 3] * app_ctx->model_height - letter_box->y_pad;
        int model_in_w = app_ctx->model_width;
        int model_in_h = app_ctx->model_height;
        result->object[last_count].box.left   = (int)(clamp(x1, 0, model_in_w) / letter_box->scale); // Face box
        result->object[last_count].box.top    = (int)(clamp(y1, 0, model_in_h) / letter_box->scale);
        result->object[last_count].box.right  = (int)(clamp(x2, 0, model_in_w) / letter_box->scale);
        result->object[last_count].box.bottom = (int)(clamp(y2, 0, model_in_h) / letter_box->scale);
        result->object[last_count].score = props[i];  // Confidence

        for (int j = 0; j < 5; ++j) { // Facial feature points
            float ponit_x = landms[n * 10 + 2 * j] * app_ctx->model_width - letter_box->x_pad;
            float ponit_y = landms[n * 10 + 2 * j + 1] * app_ctx->model_height - letter_box->y_pad;
            result->object[last_count].ponit[j].x = (int)(clamp(ponit_x, 0, model_in_w) / letter_box->scale);
            result->object[last_count].ponit[j].y = (int)(clamp(ponit_y, 0, model_in_h) / letter_box->scale);
        }
        last_count++;
    }

    result->count = last_count;

    return 0;
}

int init_retinaface_model(const char *model_path, rknn_app_context_t *app_ctx) {
    int ret;
    int model_len = 0;
    char *model;
    rknn_context ctx = 0;

    // Load RKNN Model
    model_len = read_data_from_file(model_path, &model);
    if (model == NULL) {
        printf("load_model fail!\n");
        return -1;
    }

    ret = rknn_init(&ctx, model, model_len, 0);
    free(model);
    if (ret < 0) {
        printf("rknn_init fail! ret=%d\n", ret);
        return -1;
    }

    // Get Model Input Output Number
    rknn_input_output_num io_num;
    ret = rknn_query(ctx, RKNN_QUERY_IN_OUT_NUM, &io_num, sizeof(io_num));
    if (ret != RKNN_SUCC) {
        printf("rknn_query fail! ret=%d\n", ret);
        return -1;
    }
    printf("model input num: %d, output num: %d\n", io_num.n_input, io_num.n_output);

    // Get Model Input Info
    printf("input tensors:\n");
    rknn_tensor_attr input_attrs[io_num.n_input];
    memset(input_attrs, 0, sizeof(input_attrs));
    for (int i = 0; i < io_num.n_input; i++) {
        input_attrs[i].index = i;
        ret = rknn_query(ctx, RKNN_QUERY_INPUT_ATTR, &(input_attrs[i]), sizeof(rknn_tensor_attr));
        if (ret != RKNN_SUCC) {
            printf("rknn_query fail! ret=%d\n", ret);
            return -1;
        }
        dump_tensor_attr(&(input_attrs[i]));
    }

    // Get Model Output Info
    printf("output tensors:\n");
    rknn_tensor_attr output_attrs[io_num.n_output];
    memset(output_attrs, 0, sizeof(output_attrs));
    for (int i = 0; i < io_num.n_output; i++) {
        output_attrs[i].index = i;
        ret = rknn_query(ctx, RKNN_QUERY_OUTPUT_ATTR, &(output_attrs[i]), sizeof(rknn_tensor_attr));
        if (ret != RKNN_SUCC) {
            printf("rknn_query fail! ret=%d\n", ret);
            return -1;
        }
        dump_tensor_attr(&(output_attrs[i]));
    }

    // Set to context
    app_ctx->rknn_ctx = ctx;
    app_ctx->io_num = io_num;
    app_ctx->input_attrs = (rknn_tensor_attr *)malloc(io_num.n_input * sizeof(rknn_tensor_attr));
    memcpy(app_ctx->input_attrs, input_attrs, io_num.n_input * sizeof(rknn_tensor_attr));
    app_ctx->output_attrs = (rknn_tensor_attr *)malloc(io_num.n_output * sizeof(rknn_tensor_attr));
    memcpy(app_ctx->output_attrs, output_attrs, io_num.n_output * sizeof(rknn_tensor_attr));

    if (input_attrs[0].fmt == RKNN_TENSOR_NCHW) {
        printf("model is NCHW input fmt\n");
        app_ctx->model_channel = input_attrs[0].dims[2];
        app_ctx->model_height  = input_attrs[0].dims[1];
        app_ctx->model_width   = input_attrs[0].dims[0];
    } else {
        printf("model is NHWC input fmt\n");
        app_ctx->model_height = input_attrs[0].dims[2];
        app_ctx->model_width = input_attrs[0].dims[1];
        app_ctx->model_channel = input_attrs[0].dims[0];
    }
    printf("model input height=%d, width=%d, channel=%d\n",
           app_ctx->model_height, app_ctx->model_width, app_ctx->model_channel);

    return 0;
}

int release_retinaface_model(rknn_app_context_t *app_ctx) {
    if (app_ctx->input_attrs != NULL) {
        free(app_ctx->input_attrs);
        app_ctx->input_attrs = NULL;
    }
    if (app_ctx->output_attrs != NULL) {
        free(app_ctx->output_attrs);
        app_ctx->output_attrs = NULL;
    }
    if (app_ctx->rknn_ctx != 0) {
        rknn_destroy(app_ctx->rknn_ctx);
        app_ctx->rknn_ctx = 0;
    }
    return 0;
}

int inference_retinaface_model(rknn_app_context_t *app_ctx, image_buffer_t *src_img, retinaface_result *out_result) {
    int ret;
    image_buffer_t img;
    letterbox_t letter_box;
    rknn_input inputs[1];
    rknn_output outputs[app_ctx->io_num.n_output];
    memset(&img, 0, sizeof(image_buffer_t));
    memset(inputs, 0, sizeof(inputs));
    memset(outputs, 0, sizeof(rknn_output) * 3);
    memset(&letter_box, 0, sizeof(letterbox_t));
    int bg_color = 114;//letterbox background pixel

    // Pre Process
    img.width = app_ctx->model_width;
    img.height = app_ctx->model_height;
    img.format = IMAGE_FORMAT_RGB888;
    img.size = get_image_size(&img);
    img.virt_addr = (unsigned char *)malloc(img.size);

    if (img.virt_addr == NULL) {
        printf("malloc buffer size:%d fail!\n", img.size);
        return -1;
    }

    ret = convert_image_with_letterbox(src_img, &img, &letter_box, bg_color);
    if (ret < 0) {
        printf("convert_image fail! ret=%d\n", ret);
        return -1;
    }

    // Set Input Data
    inputs[0].index = 0;
    inputs[0].type  = RKNN_TENSOR_UINT8;
    inputs[0].fmt   = RKNN_TENSOR_NHWC;
    inputs[0].size  = app_ctx->model_width * app_ctx->model_height * app_ctx->model_channel;
    inputs[0].buf   = img.virt_addr;

    ret = rknn_inputs_set(app_ctx->rknn_ctx, 1, inputs);
    if (ret < 0) {
        printf("rknn_input_set fail! ret=%d\n", ret);
        return -1;
    }

    // Run
    printf("rknn_run\n");
    ret = rknn_run(app_ctx->rknn_ctx, nullptr);
    if (ret < 0) {
        printf("rknn_run fail! ret=%d\n", ret);
        return -1;
    }

    // Get Output
    for (int i = 0; i < app_ctx->io_num.n_output; i++) {
        outputs[i].index = i;
        outputs[i].want_float = 1;
    }
    ret = rknn_outputs_get(app_ctx->rknn_ctx, 3, outputs, NULL);
    if (ret < 0) {
        printf("rknn_outputs_get fail! ret=%d\n", ret);
        goto out;
    }

    ret = post_process_retinaface(app_ctx, src_img, outputs, out_result, &letter_box);
    if (ret < 0) {
        printf("post_process_retinaface fail! ret=%d\n", ret);
        return -1;
    }
    // Remeber to release rknn output
    rknn_outputs_release(app_ctx->rknn_ctx, 3, outputs);

out:
    if (img.virt_addr != NULL) {
        free(img.virt_addr);
    }

    return ret;
}

